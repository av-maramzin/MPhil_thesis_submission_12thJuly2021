\chapter{Summary \& Conclusions}
\label{conclusion}
\quad Parallelism has become pervasive in the modern computing world. Parallel hardware is everywhere, but to exploit the available resources software has to be effectively mapped onto that hardware. The areas of \textit{software parallelization} and \textit{parallel software development} are extremely important. Despite decades of academic research and industrial investment into the area, the human expert still has a major role to play. Our state-of-the-art literature review shows that there are still no automatic solutions that could fully replace an expert programmer and at the same time guarantee program correctness and achieve performance results comparable to "handmade" parallel software.\newline\null
\quad To achieve the best result a programmer has to work on multiple conceptual levels starting from problem decomposition and algorithm choice down to low-level loop transformations. In this thesis, we fully acknowledge the role of the human expert, but provide the latter with an \textit{assistant solution}, which aims at alleviating the software parallelization and parallel software development tasks. The solution is as multifaceted as the problem itself, and also spans several conceptual levels. It consists of two components: a tool plus methodology and a library of parallel primitives. The tool aims to alleviate the task of sequential software parallelization by guiding a programmer through the process. The library can be used as a set of ready parallel solutions for specific problems.\newline\null
\quad The tool aims to assist human experts by guiding them directly towards the most interesting program loops from the perspective of software parallelization, thus alleviating the parallelizable code search process and delivering savings for this costly human resource. We have developed a novel machine learning based approach to predicting whether or not a loop is parallelizable. We combine this prediction with traditional profiling information and develop a ranking function that prioritizes low-risk, high-gain loop candidates, which are finally presented to the user.\newline\null
\quad We have evaluated our parallelization assistant against the sequential C implementations of the SNU NPB suite. We show that our assistant recognizes parallelizable loops more aggressively than conservative parallelizing compilers, thus improving parallelism discovery. We also show that our parallelization assistant can increase programmer productivity. Our experiments confirm, that equipped with our assistant, a programmer is required to examine and parallelize substantially fewer loops to achieve performance levels comparable to those of the reference OpenMP implementations of the benchmarks.\newline\null
\quad But the most important, our work has demonstrated that there is scope for machine learning based tool support in parallelization despite its inherent lack of safety. By assisting human programmers rather than replacing them, machine learning techniques have the potential to deliver productivity gains beyond what is possible by relying on traditional parallelization approaches alone.\newline\null
\quad The second component of the assistant solution is the concept of \textit{computational frameworks} along with a research prototype library implementing it. The problem of successful data structure choice stands particularly important and can vastly affect the parallelizability of programs. Moreover, we observe \textit{the problem of algorithm and data structure inseparability}. These issues have led us to a novel concept of computational frameworks, which are higher-level entities that embody algorithms and data structures into an elegant and well-structured construct. Computational frameworks can be used as parallel software design and construction primitives alleviating the task and ultimately parallelizing a wide class of applications, which fit into their computational patterns.\newline\null
\quad We shaped the concept and designed the library using a subset of the Olden benchmarks. We expressed benchmark computations through our \textit{Fractal}, \textit{Fold} and \textit{Reduce} frameworks and rewrote the benchmarks in a modern, well-structured, and crucially parallel way combining the elements of both object-oriented and functional programming. Moreover, the rejuvenated C++ benchmark versions demonstrate a good parallel performance compared to their serial legacy C counterparts. On the major benchmarks, we achieve 5-6x speedups. However, given the research prototype nature of the library, some further engineering effort is still needed.\newline\null
\quad In this thesis we demonstrate that when decades-old and well-known methods of software parallelization such as various automatic techniques run into their limits and fail to tackle the challenges of the real-world code, and more exotic methods of machine learning based techniques run into their principal problems of inherent statistical errors and the lack of safety, it is possible to acknowledge the role of a human expert and resort to various assisting solutions. The latter demonstrates promising results and paves an attractive future research direction.

%